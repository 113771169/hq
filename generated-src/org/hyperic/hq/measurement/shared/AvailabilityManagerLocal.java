/*
 * Generated by XDoclet - Do not edit!
 */
package org.hyperic.hq.measurement.shared;

/**
 * Local interface for AvailabilityManager.
 */
public interface AvailabilityManagerLocal
   extends javax.ejb.EJBLocalObject
{

   public org.hyperic.hq.measurement.server.session.Measurement getAvailMeasurement( org.hyperic.hq.authz.server.session.Resource resource ) ;

   public java.util.List getPlatformResources(  ) ;

   public long getDowntime( org.hyperic.hq.authz.server.session.Resource resource,long begin,long end ) throws org.hyperic.hq.measurement.MeasurementNotFoundException;

   public java.util.List getAllAvailIds(  ) ;

   public java.util.List getAvailMeasurementChildren( org.hyperic.hq.authz.server.session.Resource resource,java.lang.String resourceRelationType ) ;

   public java.util.Map getAvailMeasurementChildren( java.util.List resourceIds,java.lang.String resourceRelationType ) ;

   public java.util.List getAvailMeasurementParent( org.hyperic.hq.authz.server.session.Resource resource,java.lang.String resourceRelationType ) ;

   public java.util.Map getAvailMeasurementParent( java.util.List resourceIds,java.lang.String resourceRelationType ) ;

   /**
    * TODO: Can this method be combined with the one that takes an array?
    */
   public org.hyperic.util.pager.PageList getHistoricalAvailData( org.hyperic.hq.measurement.server.session.Measurement m,long begin,long end,org.hyperic.util.pager.PageControl pc,boolean prependUnknowns ) ;

   /**
    * Fetches historical availability encapsulating the specified time range for each measurement id in mids;
    * @param mids measurement ids
    * @param begin time range start
    * @param end time range end
    * @param interval interval of each time range window
    * @param pc page control
    * @param prependUnknowns determines whether to prepend AVAIL_UNKNOWN if the corresponding time window is not accounted for in the database. Since availability is contiguous this will not occur unless the time range precedes the first availability point.
    * @see org.hyperic.hq.measurement.MeasurementConstants#AVAIL_UNKNOWN
    */
   public org.hyperic.util.pager.PageList getHistoricalAvailData( java.lang.Integer[] mids,long begin,long end,long interval,org.hyperic.util.pager.PageControl pc,boolean prependUnknowns ) ;

   /**
    * Get the list of Raw RLE objects for a resource
    * @return List<AvailabilityDataRLE>
    */
   public java.util.List getHistoricalAvailData( org.hyperic.hq.authz.server.session.Resource res,long begin,long end ) ;

   public java.util.Map getAggregateData( java.lang.Integer[] mids,long begin,long end ) ;

   public java.util.Map getAggregateDataByTemplate( java.lang.Integer[] mids,long begin,long end ) ;

   public java.util.Map getAggregateData( java.lang.Integer[] tids,java.lang.Integer[] iids,long begin,long end ) ;

   public java.util.Map getLastAvail( java.util.Collection resources,java.util.Map measCache ) ;

   public org.hyperic.hq.product.MetricValue getLastAvail( org.hyperic.hq.measurement.server.session.Measurement m ) ;

   /**
    * Only unique measurement ids should be passed in. Duplicate measurement ids will be filtered out from the returned Map if present.
    * @return {@link Map} of {@link Integer} to {@link MetricValue} Integer is the measurementId
    */
   public java.util.Map getLastAvail( java.lang.Integer[] mids ) ;

   public java.util.List getUnavailEntities( java.util.List includes ) ;

   /**
    * Add a single Availablility Data point.
    * @mid The Measurement id
    * @mval The MetricValue to store.
    */
   public void addData( java.lang.Integer mid,org.hyperic.hq.product.MetricValue mval ) ;

   /**
    * Process Availability data. The default behavior is to send the data points to the event handlers.
    * @param availPoints List of DataPoints
    */
   public void addData( java.util.List availPoints ) ;

   /**
    * Process Availability data.
    * @param availPoints List of DataPoints
    * @param sendData Indicates whether to send the data to event handlers. The default behavior is true. If false, the calling method should call sendDataToEventHandlers directly afterwards.
    */
   public void addData( java.util.List availPoints,boolean sendData ) ;

   /**
    * This method should only be called by the AvailabilityCheckService and is used to filter availability data points based on hierarchical alerting rules.
    */
   public void sendDataToEventHandlers( java.util.Map data ) ;

}
