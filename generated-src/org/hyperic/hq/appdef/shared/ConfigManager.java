/*
 * Generated by XDoclet - Do not edit!
 */
package org.hyperic.hq.appdef.shared;

import javax.ejb.CreateException;
import javax.ejb.FinderException;
import javax.ejb.RemoveException;

import org.hyperic.hq.appdef.ConfigResponseDB;
import org.hyperic.hq.authz.server.session.AuthzSubject;
import org.hyperic.hq.authz.shared.PermissionException;
import org.hyperic.hq.common.VetoException;
import org.hyperic.util.config.ConfigResponse;
import org.hyperic.util.config.EncodingException;

/**
 * Local interface for ConfigManager.
 */
public interface ConfigManager {

    public ConfigResponseDB createConfigResponse(byte[] productResponse, byte[] measResponse, byte[] controlResponse,
                                                 byte[] rtResponse);

    /**
     * Get the ConfigResponse for the given ID, creating it if it does not
     * already exist.
     */
    public ConfigResponseDB getConfigResponse(AppdefEntityID id);

    public String getPluginName(AppdefEntityID id) throws AppdefEntityNotFoundException;

    /**
     * Get a config response object merged through the hierarchy. All entities
     * are merged with the product's config response, and any entity lower than
     * them in the config stack. Config responses defining a specific attribute
     * will override the same attribute if it was declared lower in the
     * application stack. Only entities within the same plugin will be
     * processed, so the most likely situation is a simple service + server +
     * product or server + product merge. Example: Get the SERVICE MEASUREMENT
     * merged response: PRODUCT[platform] + MEASUREMENT[platform]
     * PRODUCT[server] + MEASUREMENT[server] + PRODUCT[service] +
     * MEASUREMENT[service] Get the SERVER PRODUCT merged response:
     * PRODUCT[platform] PRODUCT[server] Get the PLATFORM PRODUCT merged
     * response: PRODUCT[platform] In addition to the configuration, some
     * inventory properties are also merged in to aid in auto-configuration done
     * by autoinventory. For Servers and Services: The install path of the
     * server is included For all Resources: The first non-loopback ip address,
     * fqdn, platform name and type.
     * @param productType One of ProductPlugin.*
     * @param id An AppdefEntityID of the object to get config for
     * @return the merged ConfigResponse
     */
    public ConfigResponse getMergedConfigResponse(AuthzSubject subject, String productType, AppdefEntityID id,
                                                  boolean required) throws AppdefEntityNotFoundException,
        ConfigFetchException, EncodingException, PermissionException;

    /**
     * Clear the validation error string for a config response, indicating that
     * the current config is valid
     */
    public void clearValidationError(AuthzSubject subject, AppdefEntityID id);

    /**
     * Update the validation error string for a config response
     * @param validationError The error string that occured during validation.
     *        If this is null, that means that no error occurred and the config
     *        is valid.
     */
    public void setValidationError(AuthzSubject subject, AppdefEntityID id, String validationError);

    /**
     * Set the config response for an entity/type combination.
     * @param id ID of the object to set the repsonse fo
     * @param response The response
     * @param type One of ProductPlugin.TYPE_*
     * @return an array of entities which may be affected by the change in
     *         configuration. For updates to platform and service configs, there
     *         are no other entities other than the given ID returned. If a
     *         server is updated, the associated services may require changes.
     *         The passed entity will always be returned in the array.
     */
    public AppdefEntityID setConfigResponse(AuthzSubject subject, AppdefEntityID id, ConfigResponse response,
                                            String type, boolean sendConfigEvent) throws ConfigFetchException,
        AppdefEntityNotFoundException, PermissionException, EncodingException, FinderException;

    public AppdefEntityID configureResponse(AuthzSubject subject, ConfigResponseDB existingConfig,
                                            AppdefEntityID appdefID, byte[] productConfig, byte[] measurementConfig,
                                            byte[] controlConfig, byte[] rtConfig, Boolean userManaged,
                                            boolean sendConfigEvent, boolean force);

    /**
     * Update the appdef entities based on TypeInfo
     */
    public void updateAppdefEntities(String pluginName, org.hyperic.hq.product.TypeInfo[] entities)
        throws FinderException, RemoveException, CreateException, VetoException;

}
