/*
 * Generated by XDoclet - Do not edit!
 */
package org.hyperic.hq.autoinventory.shared;

/**
 * Local interface for AutoinventoryManager.
 */
public interface AutoinventoryManagerLocal
   extends javax.ejb.EJBLocalObject
{
   /**
    * Get server signatures for a set of servertypes.
    * @param serverTypes A List of ServerTypeValue objects representing the server types to get signatures for. If this is null, all server signatures are returned.
    * @return A Map, where the keys are the names of the ServerTypeValues, and the values are the ServerSignature objects.
    */
   public java.util.Map getServerSignatures( org.hyperic.hq.authz.server.session.AuthzSubject subject,java.util.List serverTypes ) throws javax.ejb.FinderException, org.hyperic.hq.autoinventory.AutoinventoryException;

   /**
    * Check if a given Appdef entity supports runtime auto-discovery.
    * @param id The entity id to check.
    * @return true if the given resource supports runtime auto-discovery.
    */
   public boolean isRuntimeDiscoverySupported( org.hyperic.hq.authz.server.session.AuthzSubject subject,org.hyperic.hq.appdef.shared.AppdefEntityID id ) ;

   /**
    * Turn off runtime-autodiscovery for a server that no longer exists. Use this method when you know the appdefentity identified by "id" exists, so that we'll be able to successfully find out which agent we should create our AICommandsClient from.
    * @param id The AppdefEntityID of the resource to turn off runtime config for.
    */
   public void turnOffRuntimeDiscovery( org.hyperic.hq.authz.server.session.AuthzSubject subject,org.hyperic.hq.appdef.shared.AppdefEntityID id ) throws org.hyperic.hq.authz.shared.PermissionException;

   /**
    * Turn off runtime-autodiscovery for a server that no longer exists. We need this as a separate method call because when the server no longer exists, we have to manually specify the agent connection to use.
    * @param id The AppdefEntityID of the resource to turn off runtime config for.
    * @param agentToken Which agent controls the runtime AI scans for this resource.
    */
   public void turnOffRuntimeDiscovery( org.hyperic.hq.authz.server.session.AuthzSubject subject,org.hyperic.hq.appdef.shared.AppdefEntityID id,java.lang.String agentToken ) throws org.hyperic.hq.authz.shared.PermissionException;

   /**
    * Toggle Runtime-AI config for the given server.
    */
   public void toggleRuntimeScan( org.hyperic.hq.authz.server.session.AuthzSubject subject,org.hyperic.hq.appdef.shared.AppdefEntityID id,boolean enable ) throws org.hyperic.hq.authz.shared.PermissionException, org.hyperic.hq.autoinventory.AutoinventoryException, org.hyperic.hq.authz.server.shared.ResourceDeletedException;

   /**
    * Start an autoinventory scan.
    * @param aid The appdef entity whose agent we'll talk to.
    * @param scanConfig The scan configuration to use when scanning.
    * @param scanName The name of the scan - this is ignored (i.e. it can be null) for immediate, one-time scans.
    * @param scanDesc The description of the scan - this is ignored (i.e. it can be null) for immediate, one-time scans.
    * @param schedule Described when and how often the scan should run. If this is null, then the scan will be run as an immediate, one-time only scan.
    */
   public void startScan( org.hyperic.hq.authz.server.session.AuthzSubject subject,org.hyperic.hq.appdef.shared.AppdefEntityID aid,org.hyperic.hq.autoinventory.ScanConfigurationCore scanConfig,java.lang.String scanName,java.lang.String scanDesc,org.hyperic.hq.scheduler.ScheduleValue schedule ) throws org.hyperic.hq.agent.AgentConnectionException, org.hyperic.hq.appdef.shared.AgentNotFoundException, org.hyperic.hq.autoinventory.AutoinventoryException, org.hyperic.hq.autoinventory.DuplicateAIScanNameException, org.hyperic.hq.scheduler.ScheduleWillNeverFireException, org.hyperic.hq.authz.shared.PermissionException;

   /**
    * Start an autoinventory scan by agentToken
    */
   public void startScan( org.hyperic.hq.authz.server.session.AuthzSubject subject,java.lang.String agentToken,org.hyperic.hq.autoinventory.ScanConfigurationCore scanConfig ) throws org.hyperic.hq.agent.AgentConnectionException, org.hyperic.hq.appdef.shared.AgentNotFoundException, org.hyperic.hq.autoinventory.AutoinventoryException, org.hyperic.hq.authz.shared.PermissionException;

   /**
    * Stop an autoinventory scan.
    * @param aid The appdef entity whose agent we'll talk to.
    */
   public void stopScan( org.hyperic.hq.authz.server.session.AuthzSubject subject,org.hyperic.hq.appdef.shared.AppdefEntityID aid ) throws org.hyperic.hq.autoinventory.AutoinventoryException;

   /**
    * Get status for an autoinventory scan.
    * @param aid The appdef entity whose agent we'll talk to.
    */
   public org.hyperic.hq.autoinventory.ScanStateCore getScanStatus( org.hyperic.hq.authz.server.session.AuthzSubject subject,org.hyperic.hq.appdef.shared.AppdefEntityID aid ) throws org.hyperic.hq.appdef.shared.AgentNotFoundException, org.hyperic.hq.agent.AgentConnectionException, org.hyperic.hq.agent.AgentRemoteException, org.hyperic.hq.autoinventory.AutoinventoryException;

   /**
    * create AIHistory
    */
   public org.hyperic.hq.autoinventory.AIHistory createAIHistory( org.hyperic.hq.appdef.shared.AppdefEntityID id,java.lang.Integer groupId,java.lang.Integer batchId,java.lang.String subjectName,org.hyperic.hq.autoinventory.ScanConfigurationCore config,java.lang.String scanName,java.lang.String scanDesc,java.lang.Boolean scheduled,long startTime,long stopTime,long scheduleTime,java.lang.String status,java.lang.String errorMessage ) throws org.hyperic.hq.autoinventory.AutoinventoryException;

   /**
    * remove AIHistory
    */
   public void removeHistory( org.hyperic.hq.autoinventory.AIHistory history ) ;

   /**
    * update AIHistory
    */
   public void updateAIHistory( java.lang.Integer jobId,long endTime,java.lang.String status,java.lang.String message ) ;

   /**
    * Get status for an autoinventory scan, given the agentToken
    */
   public org.hyperic.hq.autoinventory.ScanStateCore getScanStatusByAgentToken( org.hyperic.hq.authz.server.session.AuthzSubject subject,java.lang.String agentToken ) throws org.hyperic.hq.appdef.shared.AgentNotFoundException, org.hyperic.hq.agent.AgentConnectionException, org.hyperic.hq.agent.AgentRemoteException, org.hyperic.hq.autoinventory.AutoinventoryException;

   /**
    * Called by agents to report platforms, servers, and services detected via autoinventory scans.
    * @param agentToken The token identifying the agent that sent the report.
    * @param stateCore The ScanState that was detected during the autoinventory scan.
    */
   public void reportAIData( java.lang.String agentToken,org.hyperic.hq.autoinventory.ScanStateCore stateCore ) throws org.hyperic.hq.autoinventory.AutoinventoryException;

   /**
    * Called by agents to report resources detected at runtime via monitoring-based autoinventory scans. There are some interesting situations that can occur related to synchronization between the server and agent. If runtime scans are turned off for a server, but the agent is never notified (for example if the agent is not running at the time), then the agent is going to eventually report a runtime scan that includes resources detected by that server's runtime scan. If this happens, we detect it and take the opportunity to tell the agent again that it should not perform runtime AI scans for that server. Any resources reported by that server will be ignored. A similar situation occurs when the appdef server has been deleted but the agent was never notified to turn off runtime AI. We handle this in the same way, by telling the agent to turn off runtime scans for that server, and ignoring anything in the report from that server. This method will process all platform and server merging, given by the report. Any services will be added to Zevent queue to be processed in their own transactions.
    * @param agentToken The token identifying the agent that sent the report.
    * @param crrr The CompositeRuntimeResourceReport that was generated during the runtime autoinventory scan.
    */
   public void reportAIRuntimeReport( java.lang.String agentToken,org.hyperic.hq.autoinventory.CompositeRuntimeResourceReport crrr ) throws org.hyperic.hq.autoinventory.AutoinventoryException, org.hyperic.hq.authz.shared.PermissionException, org.hyperic.hq.appdef.shared.ValidationException, org.hyperic.hq.common.ApplicationException;

   /**
    * Should only be called from RuntimePlatformAndServerMerger
    */
   public void _reportAIRuntimeReport( java.lang.String agentToken,org.hyperic.hq.autoinventory.CompositeRuntimeResourceReport crrr ) throws org.hyperic.hq.autoinventory.AutoinventoryException, org.hyperic.hq.authz.shared.PermissionException, org.hyperic.hq.appdef.shared.ValidationException, org.hyperic.hq.common.ApplicationException;

   /**
    * Merge platforms and servers from the runtime report.
    * @return a List of {@link ServiceMergeInfo} -- information from the report about services still needing to be processed
    */
   public java.util.List mergePlatformsAndServers( java.lang.String agentToken,org.hyperic.hq.autoinventory.CompositeRuntimeResourceReport crrr ) throws org.hyperic.hq.common.ApplicationException, org.hyperic.hq.autoinventory.AutoinventoryException;

   /**
    * Merge a list of {@link ServiceMergeInfo}s in HQ's appdef model
    */
   public void mergeServices( java.util.List mergeInfos ) throws org.hyperic.hq.authz.shared.PermissionException, org.hyperic.hq.common.ApplicationException;

   /**
    * Returns a list of {@link Agent}s which still need to send in a runtime scan (their last runtime scan was unsuccessfully processed)
    */
   public java.util.List findAgentsRequiringRuntimeScan(  ) ;

   public void notifyAgentsNeedingRuntimeScan(  ) ;

   public void markServiceClean( java.lang.String agentToken ) ;

   public void markServiceClean( org.hyperic.hq.appdef.Agent agent,boolean serviceClean ) ;

   public void startup(  ) ;

   /**
    * Handle ResourceZEvents for enabling runtime autodiscovery.
    * @param events A list of ResourceZevents
    */
   public void handleResourceEvents( java.util.List events ) ;

}
