/*
 * Generated by XDoclet - Do not edit!
 */
package org.hyperic.hq.escalation.shared;

import org.hyperic.hq.escalation.server.session.Escalation;
import org.hyperic.hq.escalation.server.session.EscalationState;

/**
 * Local interface for EscalationManager.
 */
public interface EscalationManagerLocal
   extends javax.ejb.EJBLocalObject
{
   /**
    * Create a new escalation chain
    * @see Escalation for information on fields
    */
   public org.hyperic.hq.escalation.server.session.Escalation createEscalation( java.lang.String name,java.lang.String description,boolean pauseAllowed,long maxWaitTime,boolean notifyAll,boolean repeat ) throws org.hyperic.hq.common.DuplicateObjectException;

   public org.hyperic.hq.escalation.server.session.EscalationState findEscalationState( org.hyperic.hq.escalation.server.session.PerformsEscalations def ) ;

   /**
    * Update an escalation chain
    * @see Escalation for information on fields
    */
   public void updateEscalation( org.hyperic.hq.authz.server.session.AuthzSubject subject,org.hyperic.hq.escalation.server.session.Escalation esc,java.lang.String name,java.lang.String description,boolean pauseAllowed,long maxWaitTime,boolean notifyAll,boolean repeat ) throws org.hyperic.hq.common.DuplicateObjectException, org.hyperic.hq.authz.shared.PermissionException;

   /**
    * Add an action to the end of an escalation chain. Any escalations currently in progress using this chain will be canceled.
    */
   public void addAction( org.hyperic.hq.escalation.server.session.Escalation e,org.hyperic.hq.events.ActionConfigInterface cfg,long waitTime ) ;

   /**
    * Remove an action from an escalation chain. Any escalations currently in progress using this chain will be canceled.
    */
   public void removeAction( org.hyperic.hq.escalation.server.session.Escalation e,java.lang.Integer actId ) ;

   /**
    * Delete an escalation chain. This method will throw an exception if the escalation chain is in use. TODO: Probably want to allow for the fact that people DO want to delete while states exist.
    */
   public void deleteEscalation( org.hyperic.hq.authz.server.session.AuthzSubject subject,org.hyperic.hq.escalation.server.session.Escalation e ) throws org.hyperic.hq.authz.shared.PermissionException, org.hyperic.hq.common.ApplicationException;

   public org.hyperic.hq.escalation.server.session.Escalation findById( java.lang.Integer id ) ;

   public org.hyperic.hq.escalation.server.session.Escalation findById( org.hyperic.hq.authz.server.session.AuthzSubject subject,java.lang.Integer id ) throws org.hyperic.hq.authz.shared.PermissionException;

   public java.util.Collection<Escalation> findAll( org.hyperic.hq.authz.server.session.AuthzSubject subject ) throws org.hyperic.hq.authz.shared.PermissionException;

   public org.hyperic.hq.escalation.server.session.Escalation findByName( org.hyperic.hq.authz.server.session.AuthzSubject subject,java.lang.String name ) throws org.hyperic.hq.authz.shared.PermissionException;

   public org.hyperic.hq.escalation.server.session.Escalation findByName( java.lang.String name ) ;

   /**
    * Start an escalation. If the entity performing escalations does not have an assigned escalation or if the escalation has already been started, then this method call will be a no-op.
    * @param def The entity performing escalations.
    * @param creator Object which will create an {@link Escalatable} object if invoking this method actually starts an escalation.
    * @return <code>true</code> if the escalation is started; <code>false</code> if not because either there is no escalation assigned to the entity or the escalation is already in progress.
    */
   public boolean startEscalation( org.hyperic.hq.escalation.server.session.PerformsEscalations def,org.hyperic.hq.escalation.server.session.EscalatableCreator creator ) ;

   public org.hyperic.hq.escalation.server.session.Escalatable getEscalatable( org.hyperic.hq.escalation.server.session.EscalationState s ) ;

   /**
    * End an escalation. This will remove all state for the escalation tied to a specific definition.
    */
   public void endEscalation( org.hyperic.hq.escalation.server.session.PerformsEscalations def ) ;

   /**
    * This method is only for internal use by the {@link EscalationRuntime}. This method deletes in batch the given escalation states.
    * @param stateIds The Ids for the escalation states to delete.
    */
   public void deleteAllEscalationStates( java.lang.Integer[] stateIds ) ;

   /**
    * This method is only for internal use by the {@link EscalationRuntime}. It ensures that we have a session setup prior to executing any actions. This method executes the action pointed at by the state, determines the next stage of the escalation and (optionally) ends it, thus unscheduling any further executions.
    */
   public void executeState( java.lang.Integer stateId ) ;

   /**
    * Find an escalation based on the type and ID of the definition.
    * @return null if the definition defined by the ID does not have any escalation associated with it
    */
   public org.hyperic.hq.escalation.server.session.Escalation findByDefId( org.hyperic.hq.escalation.server.session.EscalationAlertType type,java.lang.Integer defId ) ;

   /**
    * Set the escalation for a given alert definition and type
    */
   public void setEscalation( org.hyperic.hq.escalation.server.session.EscalationAlertType type,java.lang.Integer defId,org.hyperic.hq.escalation.server.session.Escalation escalation ) ;

   /**
    * Acknowledge an alert, potentially sending out notifications.
    * @param subject Person who acknowledged the alert
    * @param pause TODO
    */
   public boolean acknowledgeAlert( org.hyperic.hq.authz.server.session.AuthzSubject subject,org.hyperic.hq.escalation.server.session.EscalationAlertType type,java.lang.Integer alertId,java.lang.String moreInfo,long pause ) throws org.hyperic.hq.authz.shared.PermissionException;

   /**
    * See if an alert is acknowledgeable
    * @return true if the alert is currently acknowledgeable
    */
   public boolean isAlertAcknowledgeable( java.lang.Integer alertId,org.hyperic.hq.escalation.server.session.PerformsEscalations def ) ;

   /**
    * Fix an alert for a an escalation if there is one currently running.
    * @return true if there was an alert to be fixed.
    */
   public boolean fixAlert( org.hyperic.hq.authz.server.session.AuthzSubject subject,org.hyperic.hq.escalation.server.session.PerformsEscalations def,java.lang.String moreInfo ) throws org.hyperic.hq.authz.shared.PermissionException;

   /**
    * Fix an alert, potentially sending out notifications. The state of the escalation will be terminated and the alert will be marked fixed.
    * @param subject Person who fixed the alert
    */
   public void fixAlert( org.hyperic.hq.authz.server.session.AuthzSubject subject,org.hyperic.hq.escalation.server.session.EscalationAlertType type,java.lang.Integer alertId,java.lang.String moreInfo ) throws org.hyperic.hq.authz.shared.PermissionException;

   /**
    * Fix an alert, potentially sending out notifications. The state of the escalation will be terminated and the alert will be marked fixed.
    * @param subject Person who fixed the alert
    */
   public void fixAlert( org.hyperic.hq.authz.server.session.AuthzSubject subject,org.hyperic.hq.escalation.server.session.EscalationAlertType type,java.lang.Integer alertId,java.lang.String moreInfo,boolean suppressNotification ) throws org.hyperic.hq.authz.shared.PermissionException;

   /**
    * Re-order the actions for an escalation. If there are any states associated with the escalation, they will be cleared.
    * @param actions a list of {@link EscalationAction}s (already contained within the escalation) specifying the new order.
    */
   public void updateEscalationOrder( org.hyperic.hq.escalation.server.session.Escalation esc,java.util.List actions ) ;

   /**
    * Get the # of active escalations within HQ inventory
    */
   public java.lang.Number getActiveEscalationCount(  ) ;

   /**
    * Get the # of escalations within HQ inventory
    */
   public java.lang.Number getEscalationCount(  ) ;

   public java.util.List<EscalationState> getActiveEscalations( int maxEscalations ) ;

   public java.lang.String getLastFix( org.hyperic.hq.escalation.server.session.PerformsEscalations def ) ;

   /**
    * Called when subject is removed and therefore have to null out the acknowledgedBy field
    */
   public void handleSubjectRemoval( org.hyperic.hq.authz.server.session.AuthzSubject subject ) ;

   public void startup(  ) ;

}
