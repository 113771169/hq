<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
    <head>
        <title>vFabric Hyperic 4.6.5 : Dynamic Service Type Detection</title>
	    <link rel="stylesheet" href="styles/site.css" type="text/css" />
        <META http-equiv="Content-Type" content="text/html; charset=UTF-8">	    
    </head>

    <body>
<b><a href="vFabric Hyperic 4.6.5.html" title="vFabric Hyperic 4.6.5 Documentation Home">vFabric Hyperic 4.6.5 Documentation Home (Internal)</a>
 - <a href="https://www.vmware.com/support/pubs/vfabric-hyperic.html">vFabric Hyperic 4.6.5 Documentation Home (Online)</a>
 -  <a href="https://www.vmware.com/support/vfabric-hyperic/doc/vfabric-hyperic-rn-4.6.5.html">Hyperic 4.6.5 Release Notes</a> </b>
 <p>
 <p>
	    <table class="pagecontent" border="0" cellpadding="0" cellspacing="0" width="100%" bgcolor="#ffffff">
		    <tr>
			    <td valign="top" class="pagebody">
				    <div class="pageheader">
					    <span class="pagetitle">
                            vFabric Hyperic 4.6.5 : Dynamic Service Type Detection
                                                    </span>
				    </div>
				    <div class="pagesubheading">
					    This page last changed on Jan 04, 2012 by <font color="#0050B2">mmcgarry</font>.
				    </div>

				    <style type='text/css'>/*<![CDATA[*/
div.rbtoc1325699818453 {margin-left: 1.5em;padding: 0px;}
div.rbtoc1325699818453 ul {list-style: disc;margin-left: 0px;padding-left: 20px;}
div.rbtoc1325699818453 li {margin-left: 0px;padding-left: 0px;}

/*]]>*/</style><div class='rbtoc1325699818453'>
<ul>
    <li><a href='#DynamicServiceTypeDetection-IntroductiontoDynamicServiceTypeDetection'>Introduction to Dynamic Service Type Detection</a></li>
    <li><a href='#DynamicServiceTypeDetection-ImplementdiscoverServiceTypesmethod'>Implement discoverServiceTypes method</a></li>
    <li><a href='#DynamicServiceTypeDetection-UsingServiceTypeInfo'>Using ServiceTypeInfo</a></li>
    <li><a href='#DynamicServiceTypeDetection-UsingServiceType'>Using ServiceType</a></li>
    <li><a href='#DynamicServiceTypeDetection-Handleservicesettings'>Handle service settings</a></li>
    <li><a href='#DynamicServiceTypeDetection-Customproperties'>Custom properties</a></li>
    <li><a href='#DynamicServiceTypeDetection-Properties'>Properties</a></li>
    <li><a href='#DynamicServiceTypeDetection-Plugins'>Plugins</a></li>
    <li><a href='#DynamicServiceTypeDetection-Controlactions'>Control actions</a></li>
    <li><a href='#DynamicServiceTypeDetection-Measurements'>Measurements</a></li>
</ul></div>

<h1><a name="DynamicServiceTypeDetection-IntroductiontoDynamicServiceTypeDetection"></a>Introduction to Dynamic Service Type Detection</h1>

<p>Most service types are defined in the XML descriptor for the plugin that manages the host server. This works well for services whose name, configuration options, related plugin implementations, and metrics structures are known in advance and can be specified when you develop the plugin. </p>

<p><em>Dynamic service type detection</em> is a method of auto-discovery that can detect supports runtime creation of new resource types.</p>

<p><tt>ServerDetector</tt>, Hyperic's base autodiscovery class, contains the <tt>discoverServiceTypes(ConfigResponse):Set</tt> function, which is called during runtime discovery operation. This method is called prior to <tt>discoverServices(ConfigResponse):List</tt> which usually handles runtime service discovery. </p>

<p>A custom discovery class that extends a Hyperic auto-discovery support class discovers service types before the service instances. The service structure is then reported to the Hyperic server. Structures on server are updated from multiple sources, hence the services of the same type must have the same configuration schema. </p>

<div class='panelMacro'><table class='noteMacro'><colgroup><col width='24'><col></colgroup><tr><td valign='top'><img src="images/icons/emoticons/warning.gif" width="16" height="16" align="absmiddle" alt="" border="0"></td><td>Dynamic service type creation does support the run-time definition of resource configuration option (the resource data defined as <tt>&lt;option&gt;</tt> elements for a resource type, and presented and updated on the <b>Configuration Properties</b> page for a resource instance). For this reason, the <tt>template</tt> attribute for a metric for a service that awill be created at runtime must be specified explicitly, rather than by reference to a configuration <tt>&lt;option&gt;</tt>.</td></tr></table></div>


<p>The sections that follow describe this method. The instructions assume a plugin whose resource structure is defined in the XML descriptor like this:  </p>

<div class="code panel" style="border-width: 1px;"><div class="codeContent panelContent">
<div id="root">
		<pre class="theme: Confluence; brush: xml; gutter: false">&lt;plugin name="myplugin"&gt;
  ...
  &lt;server name="MyServer"&gt;
    ...
&lt;/plugin&gt;</pre>
		</div>
</div></div>

<p>Note that no service types are defined for the server type. Since we are about to define these services dynamically, we expect similar result as if these services would be hard coded into the plugin descriptor:</p>
<div class="code panel" style="border-width: 1px;"><div class="codeContent panelContent">
<div id="root">
		<pre class="theme: Confluence; brush: xml; gutter: false">&lt;plugin name="myplugin"&gt;
  ...
  &lt;server name="MyServer"&gt;
    ...
    &lt;!-- --&gt;
    &lt;service name="Service A"&gt;
      ...
    &lt;/service&gt;
    &lt;service name="Service B"&gt;
      ...
    &lt;/service&gt;
    &lt;service name="Service C"&gt;
      ...
    &lt;/service&gt;
&lt;/plugin&gt;</pre>
		</div>
</div></div>

<h1><a name="DynamicServiceTypeDetection-ImplementdiscoverServiceTypesmethod"></a>Implement discoverServiceTypes method</h1>

<p>This method has to return a Set containing <tt>ServiceType objects</tt>. The method skeleton would look something like this:</p>
<div class="code panel" style="border-width: 1px;"><div class="codeContent panelContent">
<div id="root">
		<pre class="theme: Confluence; brush: java; gutter: false">@Override
protected Set&lt;ServiceType&gt; discoverServiceTypes(ConfigResponse serverConfig)
    throws PluginException {
    Set&lt;ServiceType&gt; serviceTypes = new HashSet&lt;ServiceType&gt;();

    // Do your magic...

    return serviceTypes;
}</pre>
		</div>
</div></div>

<p>The function should perform all operations required to to discover and build your service types structures. You may choose to create a separate factory class to perform these operations ---regardless of your implementation, you must pass the appropriate data to the factory methods, unless you decide to hard code the service type names. At a minimum you must define the managed product name - which corresponds to the plugin name, and the server type that hosts your services. Although you technically can supply this data, it may be preferable to query for this data at runtime.</p>

<p>You can obtain Plugin name from <tt>ProductPlugin</tt> using the <tt>getName():String</tt> function. To access the object within, use the <tt>getProductPlugin():ProductPluginfunction</tt>.</p>

<p>Creation of service type structures requires knowing the hosting server type, which you can obtain using the <tt>getTypeInfo():TypeInfo</tt> method. The type you need is <tt>ServerTypeInfo</tt> and casting is needed respectively. For example::</p>

<div class="code panel" style="border-width: 1px;"><div class="codeContent panelContent">
<div id="root">
		<pre class="theme: Confluence; brush: java; gutter: false">try {
    MyServiceTypeFactory serviceTypeFactory = new MyServiceTypeFactory();

    ProductPlugin pp = getProductPlugin();
    ServerTypeInfo sTypeInfo = (ServerTypeInfo)getTypeInfo();

    serviceTypes = serviceTypeFactory.createTypes(
        pp,
        sTypeInfo
        /*, myDiscoveredServices*/); // object with discovered services

    } catch (Exception e) {
        throw new PluginException(e.getMessage(), e);
    }</pre>
		</div>
</div></div>

<h1><a name="DynamicServiceTypeDetection-UsingServiceTypeInfo"></a>Using ServiceTypeInfo</h1>

<p>The class constructor <tt>ServiceTypeInfo(String name, String description, ServerTypeInfo server)</tt> takes these arguments:</p>

<ul>
	<li><tt>name</tt>---Fully qualified service name. This is the one you will see under Monitoring Defaults.</li>
</ul>


<ul>
	<li><tt>description</tt>---Service description.</li>
</ul>


<ul>
	<li><tt>server</tt>---Parent server type in form of <tt>ServerTypeInfo</tt>.</li>
</ul>


<p>Here is an example of how you could construct the class. <tt>ServerTypeInfo</tt> is passed using the <tt>sTypeInfo</tt> variable.</p>

<div class="code panel" style="border-width: 1px;"><div class="codeContent panelContent">
<div id="root">
		<pre class="theme: Confluence; brush: java; gutter: false">ServiceTypeInfo typeInfo = new ServiceTypeInfo(
    "MyServer Service A",
    "Autodetected Service A which MyServer",
    sTypeInfo);

ServiceTypeInfo typeInfo = new ServiceTypeInfo(
    sTypeInfo.getName() + ' ' + name,
    "Autodetected service type for " + name,
    sTypeInfo);</pre>
		</div>
</div></div>

<h1><a name="DynamicServiceTypeDetection-UsingServiceType"></a>Using ServiceType</h1>

<p>The <tt>ServiceType(String serviceName, String productName, ServiceTypeInfo info)</tt> takes these arguments:  </p>

<ul>
	<li><tt>serviceName</tt>---The unique service type name (unique with respect to server type).</li>
</ul>


<ul>
	<li><tt>productName</tt>---The name of the product containing this service.</li>
</ul>


<ul>
	<li><tt>info</tt>---The <tt>ServiceTypeInfo</tt> describing this service type.</li>
</ul>


<p>You need  construct a new <tt>ServiceType</tt> object you need to use the service name and plugin name as those would exist in XML. Last parameter <tt>typeInfo</tt> is the one you've just created.</p>

<div class="code panel" style="border-width: 1px;"><div class="codeContent panelContent">
<div id="root">
		<pre class="theme: Confluence; brush: java; gutter: false">ServiceType type = new ServiceType("Service A", "myplugin", typeInfo);

ServiceType type = new ServiceType(name, productName, typeInfo);</pre>
		</div>
</div></div>

<h1><a name="DynamicServiceTypeDetection-Handleservicesettings"></a>Handle service settings</h1>

<p>After the basic ServiceType is created you are not yet done. At this point it only contain the service name, what is the hosting server type and to which plugin it belongs to. Now you need to add all the missing information related to properties, custom properties, plugins, control actions and metrics. As you remember config options can't be added. These all will be added to ServiceType  object.</p>

<p>Even if you don't have anything to set (no properties or control action, etc) it's still adviced to call appropriate methods to initialize empty information. Fail to do this may result errors and exceptions.</p>

<h1><a name="DynamicServiceTypeDetection-Customproperties"></a>Custom properties</h1>

<p>Adding custom properties is done using method setCustomProperties(ConfigSchema):void. Always set atleast empty schema. If you want to add some properties, add StringConfigOption  to the schema.</p>

<div class="code panel" style="border-width: 1px;"><div class="codeContent panelContent">
<div id="root">
		<pre class="theme: Confluence; brush: java; gutter: false">private void addCustomProperties(final ServiceType serviceType) {

    final ConfigSchema propertiesSchema = new ConfigSchema();
    propertiesSchema.addOption(new StringConfigOption("myopt", "myval"));

    serviceType.setCustomProperties(propertiesSchema);
}</pre>
		</div>
</div></div>

<div class='panelMacro'><table class='noteMacro'><colgroup><col width='24'><col></colgroup><tr><td valign='top'><img src="images/icons/emoticons/warning.gif" width="16" height="16" align="absmiddle" alt="" border="0"></td><td>Setting custom properties differs slightly what we've used to see during the normal resource discovery methods. There properties are setted using ConfigResponse class.</td></tr></table></div>

<h1><a name="DynamicServiceTypeDetection-Properties"></a>Properties</h1>

<p>Properties for the ServiceType  are setted using method setProperties(ConfigResponse):void. Use method setValue(String, String):void  from ConfigResponse to set values.</p>
<div class="code panel" style="border-width: 1px;"><div class="codeContent panelContent">
<div id="root">
		<pre class="theme: Confluence; brush: java; gutter: false">private void addProperties(final ServiceType serviceType) {

    final ConfigResponse properties = new ConfigResponse();
    properties.setValue("myprop", "myval");

    serviceType.setProperties(properties);
}</pre>
		</div>
</div></div>

<h1><a name="DynamicServiceTypeDetection-Plugins"></a>Plugins</h1>

<p>If servicetype is to support any kind of measurement functions it need to know the plugin implementation. Same goes with autoinventory and other plugin types. These are setted using same method what we just saw by setting properties.</p>

<div class="code panel" style="border-width: 1px;"><div class="codeContent panelContent">
<div id="root">
		<pre class="theme: Confluence; brush: java; gutter: false">private void addPlugins(final ServiceType serviceType) {

    final ConfigResponse pluginClasses = new ConfigResponse();
    pluginClasses.setValue("autoinventory", "hq.training.MyDetector");
    pluginClasses.setValue("measurement", "hq.training.MyMeasurementPlugin");

    serviceType.setPluginClasses(pluginClasses);
}</pre>
		</div>
</div></div>

<h1><a name="DynamicServiceTypeDetection-Controlactions"></a>Control actions</h1>

<p>Supported control actions are setted using method setControlActions(Set):void. Set contains a list of actions as type of String.</p>

<div class="code panel" style="border-width: 1px;"><div class="codeContent panelContent">
<div id="root">
		<pre class="theme: Confluence; brush: java; gutter: false">private void addControlActions(final ServiceType serviceType) {

    Set&lt;String&gt; actions = new HashSet&lt;String&gt;();
    actions.add("start"):
    actions.add("stop"):

    serviceType.setControlActions(actions);
}</pre>
		</div>
</div></div>

<h1><a name="DynamicServiceTypeDetection-Measurements"></a>Measurements</h1>

<p>Metrics are added using method setMeasurements(MeasurementInfos):void  where MeasurementInfos contains the actual metrics. One metric entity is represented by class MeasurementInfo. These are tied together using method addMeasurementInfo(MeasurementInfo):void  from class MeasurementInfos.</p>

<p>We can usually create metrics using same type of helper method, except the availability metric which usually have different type of layout. To simplify metric creation we use two methods, one to create measurement properties and second to add these properties to actual metric.</p>

<div class="code panel" style="border-width: 1px;"><div class="codeContent panelContent">
<div id="root">
		<pre class="theme: Confluence; brush: java; gutter: false">private MeasurementInfo createAvailabilityMeasurement(final ServiceType serviceType) {
    Properties measurementProperties = new Properties();

    measurementProperties.put(MeasurementInfo.ATTR_UNITS, MeasurementConstants.UNITS_PERCENTAGE);
    measurementProperties.put(MeasurementInfo.ATTR_NAME, Metric.ATTR_AVAIL);
    measurementProperties.put(MeasurementInfo.ATTR_ALIAS, Metric.ATTR_AVAIL);
    measurementProperties.put(MeasurementInfo.ATTR_COLLECTION_TYPE, "dynamic");
    measurementProperties.put(MeasurementInfo.ATTR_CATEGORY, MeasurementConstants.CAT_AVAILABILITY);
    measurementProperties.put(MeasurementInfo.ATTR_INDICATOR, "true");
    measurementProperties.put(MeasurementInfo.ATTR_DEFAULTON, "true");
    measurementProperties.put(MeasurementInfo.ATTR_INTERVAL, "600000");

    measurementProperties.put(MeasurementInfo.ATTR_TEMPLATE, "dummy-domain::Availability");

    return createMeasurementInfo(measurementProperties);
}

private MeasurementInfo createMeasurementInfo(Properties measurementProperties) {
    MeasurementInfo metric = new MeasurementInfo();

    try {
        metric.setAttributes(measurementProperties);
    } catch (Exception e) {
        log.warn("Error setting metric attributes.  Cause: " + e.getMessage());
    }

    // Make sure we're using upper case letters for category
    metric.setCategory(metric.getCategory().toUpperCase());

    return metric;
}</pre>
		</div>
</div></div>

<p>Next we can use similar type of template for other than availability metrics. If you need to modify metric parameters, create separate function respectively. To simplify this method example we use metric name which also qualify as metric alias. Usually metric name differs from alias by being more human readable.</p>

<div class="code panel" style="border-width: 1px;"><div class="codeContent panelContent">
<div id="root">
		<pre class="theme: Confluence; brush: java; gutter: false">private MeasurementInfo createMeasurementInfo(ServiceType serviceType,
                                              String metric) {

    Properties measurementProperties = new Properties();

    measurementProperties.put(MeasurementInfo.ATTR_UNITS, "none");
    measurementProperties.put(MeasurementInfo.ATTR_NAME, metric);
    measurementProperties.put(MeasurementInfo.ATTR_ALIAS, metric);
    measurementProperties.put(MeasurementInfo.ATTR_COLLECTION_TYPE,"dynamic");
    measurementProperties.put(MeasurementInfo.ATTR_RATE, "none");
    measurementProperties.put(MeasurementInfo.ATTR_INTERVAL, "300000");
    measurementProperties.put(MeasurementInfo.ATTR_CATEGORY, MeasurementConstants.CAT_UTILIZATION);
    measurementProperties.put(MeasurementInfo.ATTR_INDICATOR, "false");
    measurementProperties.put(MeasurementInfo.ATTR_DEFAULTON, "false");

    measurementProperties.put(MeasurementInfo.ATTR_TEMPLATE, "dummy-domain::"+metric);
    return createMeasurementInfo(measurementProperties);
}</pre>
		</div>
</div></div>

<p>We just used hard coded metric template which only added metric name as an attribute. If this is all you need to collect your metrics, you're good. However in real world there is propably need to pass some configuration parameters. Instead of just hardcode metric template, we could use helper function to add template to measurement properties.</p>

<div class="code panel" style="border-width: 1px;"><div class="codeContent panelContent">
<div id="root">
		<pre class="theme: Confluence; brush: java; gutter: false">private void addMeasurementTemplate(Properties measurementProperties,
                                    ProductPlugin productPlugin,
                                    ServiceType serviceType) {
    TokenReplacer replacer = new TokenReplacer();

    final String objectName = serviceType.getProperties().getValue(serviceType.getInfo().getName() + ".OBJECT");

    addFilter(MeasurementInfo.ATTR_ALIAS, measurementProperties, replacer);
    replacer.addFilter("OBJECT", objectName);
    final String template = filter(productPlugin.getPluginProperty("template"), replacer);

    measurementProperties.put(MeasurementInfo.ATTR_TEMPLATE, template);
}

private String filter(String val, TokenReplacer replacer) {
    return replacer.replaceTokens(val);
}</pre>
		</div>
</div></div>

<p>Above example is using same TokenReplacer used to translate variables during metric collection. We could Store the metric template to xml using property tag and write properties to there.</p>

<div class="code panel" style="border-width: 1px;"><div class="codeContent panelContent">
<div id="root">
		<pre class="theme: Confluence; brush: xml; gutter: false">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;plugin name="myplugin"&gt;

  &lt;property name="template" value="service-domain:Object=${OBJECT}:${alias}" /&gt;</pre>
		</div>
</div></div>

<p>These translated properties can be stored to ServiceType using methods we saw in addProperties function. These properties goes to global set and has to be unique, that's wy we are using serviceType.getInfo().getName() + ".OBJECT" and not just OBJECT.</p>

				    
                    			    </td>
		    </tr>
	    </table>
	    <table border="0" cellpadding="0" cellspacing="0" width="100%">
			<tr>
				<td height="12" background="http://support.hyperic.com/images/border/border_bottom.gif"><img src="images/border/spacer.gif" width="1" height="1" border="0"/></td>
			</tr>
		    <tr>
			    <td align="center"><font color="grey">Document generated by Confluence on Feb 15, 2012 15:43</font></td>
		    </tr>
	    </table>
    </body>
</html>
