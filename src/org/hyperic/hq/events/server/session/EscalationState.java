/*
 * NOTE: This copyright does *not* cover user programs that use HQ
 * program services by normal system calls through the application
 * program interfaces provided as part of the Hyperic Plug-in Development
 * Kit or the Hyperic Client Development Kit - this is merely considered
 * normal use of the program, and does *not* fall under the heading of
 * "derived work".
 *
 * Copyright (C) [2004, 2005, 2006], Hyperic, Inc.
 * This file is part of HQ.
 *
 * HQ is free software; you can redistribute it and/or modify
 * it under the terms version 2 of the GNU General Public License as
 * published by the Free Software Foundation. This program is distributed
 * in the hope that it will be useful, but WITHOUT ANY WARRANTY; without
 * even the implied warranty of MERCHANTABILITY or FITNESS FOR A
 * PARTICULAR PURPOSE. See the GNU General Public License for more
 * details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
 * USA.
 */

package org.hyperic.hq.events.server.session;

import java.io.Serializable;
// Generated Nov 15, 2006 9:03:57 PM by Hibernate Tools 3.2.0.beta8


/**
 * EscalationState generated by hbm2java
 */
public class EscalationState implements Serializable, Cloneable {

    public static EscalationState newInstance() {
        return new EscalationState();
    }

    // Fields

    /**
     * The current escalation leven in the chain.  I.e.,
     * current escalation level == actions[currentLevel].
     */
    private int currentLevel;
    /**
     * If true, then wait for max("waitTime", EscalationAction.waitTime)
     * before escalating up the chain.
     * If false, then wait EscalationAction.waitTime before escalating up
     * the chain.
     */
    private boolean pauseEscalation;
    /**
     * meaningful if pauseEscalation == true.
     * pauseWaitTime < maxWaitTime
     */
    private long pauseWaitTime;
    /**
     * If fixed, then stop escalation chain. (terminal condition)
     */
    private boolean fixed;
    /**
     * "updateBy" has taken ownership of this issue at the
     * current escalation level.
     */
    private boolean acknowledge;

    /**
     * if true, escalation is active
     */
    private boolean active;
    /**
     * escalation chain state.
     */
    private String updateBy;

    private long modifiedTime;

    // Constructors

    /**
     * default constructor
     */
    protected EscalationState() {
    }

    // Property accessors
    /**
     * *         The current escalation leven in the chain.  I.e.,
     * current escalation level == actions[currentLevel].
     */
    public int getCurrentLevel() {
        return this.currentLevel;
    }

    public void setCurrentLevel(int currentLevel) {
        if (this.currentLevel != currentLevel) {
            // use low tech approach, could use custome usertype + interceptor
            // but requires more investigation
            setModifiedTime(System.currentTimeMillis());
        }
        this.currentLevel = currentLevel;
    }

    /**
     * *         If true, then wait for max("waitTime", EscalationAction.waitTime)
     * before escalating up the chain.
     * If false, then wait EscalationAction.waitTime before escalating up
     * the chain.
     */
    public boolean isPauseEscalation() {
        return this.pauseEscalation;
    }

    public void setPauseEscalation(boolean pauseEscalation) {
        if (this.pauseEscalation != pauseEscalation) {
            setModifiedTime(System.currentTimeMillis());
        }
        this.pauseEscalation = pauseEscalation;
    }

    /**
     * *         meaningful if pauseEscalation == true.
     * pauseWaitTime < maxWaitTime
     */
    public long getPauseWaitTime() {
        return this.pauseWaitTime;
    }

    public void setPauseWaitTime(long pauseWaitTime) {
        if (this.pauseWaitTime != pauseWaitTime) {
            setModifiedTime(System.currentTimeMillis());
        }
        this.pauseWaitTime = pauseWaitTime;
    }

    /**
     * *         If fixed, then stop escalation chain. (terminal condition)
     */
    public boolean isFixed() {
        return this.fixed;
    }

    public void setFixed(boolean fixed) {
        if (this.fixed != fixed) {
            setModifiedTime(System.currentTimeMillis());
        }
        this.fixed = fixed;
    }

    /**
     * *         "updateBy" has taken ownership of this issue at the
     * current escalation level.
     */
    public boolean isAcknowledge() {
        return this.acknowledge;
    }

    public void setAcknowledge(boolean acknowledge) {
        if (this.acknowledge != acknowledge) {
            setModifiedTime(System.currentTimeMillis());
        }
        this.acknowledge = acknowledge;
    }

    public boolean isActive() {
        return active;
    }

    public void setActive(boolean active) {
        if (this.active != active) {
            setModifiedTime(System.currentTimeMillis());
        }
        this.active = active;
    }

    /**
     * *         escalation chain state.
     */
    public String getUpdateBy() {
        return this.updateBy;
    }

    public void setUpdateBy(String updateBy) {
        this.updateBy = updateBy;
    }

    /**
     * @return timestamp on state change
     */
    public long getModifiedTime() {
        return modifiedTime;
    }

    public void setModifiedTime(long modifiedTime) {
        this.modifiedTime = modifiedTime;
    }

    public boolean equals(Object obj) {
        if (this == obj) {
            return true;
        }
        if (obj == null || !(obj instanceof EscalationState)) {
            return false;
        }
        EscalationState o = (EscalationState)obj;

        return currentLevel == o.getCurrentLevel() &&
               modifiedTime == o.getModifiedTime() &&
               pauseWaitTime == o.getPauseWaitTime() &&
               acknowledge == o.isAcknowledge() &&
               fixed == o.isFixed() &&
               active == o.isActive() &&
               pauseEscalation == o.isPauseEscalation() &&
               (updateBy == o.getUpdateBy() ||
                (updateBy != null && o.getUpdateBy() != null &&
                 updateBy.equals(o.getUpdateBy())));
    }

    public int hashCode() {
        int result = 17;

        result = 37*result + (acknowledge ? 0 : 1);
        result = 37*result + (fixed ? 0 : 1);
        result = 37*result + (pauseEscalation ? 0 : 1);
        result = 37*result + (active ? 0 : 1);
        result = 37*result + currentLevel;
        result = 37*result + (int)(modifiedTime ^ (modifiedTime >>> 32));
        result = 37*result + (int)(pauseWaitTime ^ (pauseWaitTime >>> 32));
        result = 37*result + (updateBy != null ? updateBy.hashCode() : 0);

        return result;
    }

    public Object clone() {
        try {
            return super.clone();
        } catch(CloneNotSupportedException e) {
            // Can't happen
            throw new UnsupportedOperationException(e.getMessage());
        }
    }
}


