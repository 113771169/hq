/*
 * NOTE: This copyright does *not* cover user programs that use HQ
 * program services by normal system calls through the application
 * program interfaces provided as part of the Hyperic Plug-in Development
 * Kit or the Hyperic Client Development Kit - this is merely considered
 * normal use of the program, and does *not* fall under the heading of
 * "derived work".
 *
 * Copyright (C) [2004, 2005, 2006], Hyperic, Inc.
 * This file is part of HQ.
 *
 * HQ is free software; you can redistribute it and/or modify
 * it under the terms version 2 of the GNU General Public License as
 * published by the Free Software Foundation. This program is distributed
 * in the hope that it will be useful, but WITHOUT ANY WARRANTY; without
 * even the implied warranty of MERCHANTABILITY or FITNESS FOR A
 * PARTICULAR PURPOSE. See the GNU General Public License for more
 * details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
 * USA.
 */

package org.hyperic.hq.events.server.session;
// Generated Nov 15, 2006 9:03:57 PM by Hibernate Tools 3.2.0.beta8


/**
 * EscalationState generated by hbm2java
 */
public class EscalationState implements java.io.Serializable {

    public static EscalationState newInstance() {
        return new EscalationState();
    }

    // Fields

    /**
     * The current escalation leven in the chain.  I.e.,
     * current escalation level == actions[currentLevel].
     */
    private int currentLevel;
    /**
     * If true, then wait for max("waitTime", EscalationAction.waitTime)
     * before escalating up the chain.
     * If false, then wait EscalationAction.waitTime before escalating up
     * the chain.
     */
    private boolean pauseEscalation;
    /**
     * meaningful if pauseEscalation == true.
     * pauseWaitTime < maxWaitTime
     */
    private long pauseWaitTime;
    /**
     * If fixed, then stop escalation chain. (terminal condition)
     */
    private boolean fixed;
    /**
     * "updateBy" has taken ownership of this issue at the
     * current escalation level.
     */
    private boolean acknowledge;
    /**
     * escalation chain state.
     */
    private String updateBy;

    private long lastUpdate;

    // Constructors

    /**
     * default constructor
     */
    protected EscalationState() {
    }

    // Property accessors
    /**
     * *         The current escalation leven in the chain.  I.e.,
     * current escalation level == actions[currentLevel].
     */
    public int getCurrentLevel() {
        return this.currentLevel;
    }

    public void setCurrentLevel(int currentLevel) {
        this.currentLevel = currentLevel;
    }

    /**
     * *         If true, then wait for max("waitTime", EscalationAction.waitTime)
     * before escalating up the chain.
     * If false, then wait EscalationAction.waitTime before escalating up
     * the chain.
     */
    public boolean isPauseEscalation() {
        return this.pauseEscalation;
    }

    public void setPauseEscalation(boolean pauseEscalation) {
        this.pauseEscalation = pauseEscalation;
    }

    /**
     * *         meaningful if pauseEscalation == true.
     * pauseWaitTime < maxWaitTime
     */
    public long getPauseWaitTime() {
        return this.pauseWaitTime;
    }

    public void setPauseWaitTime(long pauseWaitTime) {
        this.pauseWaitTime = pauseWaitTime;
    }

    /**
     * *         If fixed, then stop escalation chain. (terminal condition)
     */
    public boolean isFixed() {
        return this.fixed;
    }

    public void setFixed(boolean fixed) {
        this.fixed = fixed;
    }

    /**
     * *         "updateBy" has taken ownership of this issue at the
     * current escalation level.
     */
    public boolean isAcknowledge() {
        return this.acknowledge;
    }

    public void setAcknowledge(boolean acknowledge) {
        this.acknowledge = acknowledge;
    }

    /**
     * *         escalation chain state.
     */
    public String getUpdateBy() {
        return this.updateBy;
    }

    public void setUpdateBy(String updateBy) {
        this.updateBy = updateBy;
    }

    /**
     * @return timestamp on state change
     */
    public long getLastUpdate() {
        return lastUpdate;
    }

    public void setLastUpdate(long lastUpdate) {
        this.lastUpdate = lastUpdate;
    }
}


