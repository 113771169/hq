/*
 * NOTE: This copyright does *not* cover user programs that use HQ
 * program services by normal system calls through the application
 * program interfaces provided as part of the Hyperic Plug-in Development
 * Kit or the Hyperic Client Development Kit - this is merely considered
 * normal use of the program, and does *not* fall under the heading of
 * "derived work".
 * 
 * Copyright (C) [2004, 2005, 2006], Hyperic, Inc.
 * This file is part of HQ.
 * 
 * HQ is free software; you can redistribute it and/or modify
 * it under the terms version 2 of the GNU General Public License as
 * published by the Free Software Foundation. This program is distributed
 * in the hope that it will be useful, but WITHOUT ANY WARRANTY; without
 * even the implied warranty of MERCHANTABILITY or FITNESS FOR A
 * PARTICULAR PURPOSE. See the GNU General Public License for more
 * details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
 * USA.
 */

package org.hyperic.hq.bizapp.client.shell;

import org.hyperic.util.PrintfFormat;
import org.hyperic.util.StringUtil;

import java.io.PrintStream;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

public class ValuePrinter {
    public static final int ATTRTYPE_STRING   = 1;
    public static final int ATTRTYPE_INT      = 2;
    public static final int ATTRTYPE_LONG     = 3;
    public static final int ATTRTYPE_LONGDATE = 4;
    public static final int ATTRTYPE_DOUBLE   = 5;

    private PrintStream  out;
    private String       format;
    private String       headerFormat;
    private String[]     headers;
    private int[]        attributes;
    private int[]        attrTypes;
    private List         prologue;
    private ValueWrapper wrapper;
    private Object       auxData;

    public void setFormat (String format) { this.format = format; }
    public void setHeaderFormat (String format) { this.headerFormat = format; }

    /**
     * Setup a new printer object which automagically creates
     * a format.  
     */
    public ValuePrinter(PrintStream out, int[] attributes){
        this.init(out, null, attributes, 
                  getStringTypes(attributes.length));
    }

    /**
     * Setup a new printer object.  All the attribute types
     * are taken to be of type String.  
     */
    public ValuePrinter(PrintStream out, String format, int[] attributes){
        this.init(out, format, attributes, 
                  getStringTypes(attributes.length));
    }

    /**
     * Setup a printer object where the attribute types are given.
     */
    public ValuePrinter(PrintStream out, String format,
                 int[] attributes, int[] attrTypes)
    {
        this.init(out, format, attributes, attrTypes);
    }

    /**
     * Setup a printer object where the attribute types are given and the
     * format is autogenerated.  attrTypes must all be convertable as
     * Strings in order to use auto-generated formatting.
     */
    public ValuePrinter(PrintStream out, int[] attributes, int[] attrTypes){
        this.init(out, null, attributes, attrTypes);
    }

    /**
     * Setup a new printer object which automagically creates
     * a format.  
     */
    public ValuePrinter(int[] attributes){
        this.init(null, null, attributes, 
                  getStringTypes(attributes.length));
    }

    /**
     * Setup a new printer object.  All the attribute types
     * are taken to be of type String.  
     */
    public ValuePrinter(String format, int[] attributes){
        this.init(null, format, attributes, 
                  getStringTypes(attributes.length));
    }

    /**
     * Setup a printer object where the attribute types are given.
     */
    public ValuePrinter(String format, int[] attributes, int[] attrTypes)
    {
        this.init(null, format, attributes, attrTypes);
    }

    /**
     * Setup a printer object where the attribute types are given and the
     * format is autogenerated.  attrTypes must all be convertable as
     * Strings in order to use auto-generated formatting.
     */
    public ValuePrinter(int[] attributes, int[] attrTypes){
        this.init(null, null, attributes, attrTypes);
    }

    private void init(PrintStream out, String format, 
                      int[] attributes, int[] attrTypes)
    {
        this.out        = out;
        this.format     = format;
        this.headers    = null;
        this.attributes = attributes;
        this.attrTypes  = attrTypes;
        this.prologue   = null;
        this.wrapper    = new ValueWrapper();

        if(attrTypes.length != attributes.length)
            throw new IllegalArgumentException("Attributes and their types " +
                                               "must be the same length");
    }

    private static int[] getStringTypes(int nVals){
        int[] res = new int[nVals];

        for(int i=0; i<nVals; i++){
            res[i] = ATTRTYPE_STRING;
        }
        return res;
    }

    private void printData(List data){
        if(this.out == null)
            return;

        for(Iterator i=data.iterator(); i.hasNext(); ){
            this.out.println((String)i.next());
        }
    }

    void setAuxData(Object auxData){
        this.auxData = auxData;
    }

    protected void setValueWrapper(ValueWrapper wrapper){
        this.wrapper = wrapper;
    }

    public void setPrologue(String prologue){
        ArrayList addList = new ArrayList();

        addList.add(prologue);
        this.setPrologue(addList);
    }

    public void setPrologue(List prologue){
        this.prologue = prologue;
    }

    List getHeaders(String format){
        ArrayList res;
        PrintfFormat fmt;
        String underScores[];
        
        fmt = new PrintfFormat(format);
        underScores = new String[this.headers.length];
        for(int i=0; i<underScores.length; i++){
            underScores[i] = 
                StringUtil.repeatChars('-', this.headers[i].length());
        }

        res = new ArrayList(2);
        if(this.prologue != null){
            res.addAll(this.prologue);
        }
        res.add(fmt.sprintf(this.headers));
        res.add(fmt.sprintf(underScores));
        return res;
    }

    List getHeaders(){
        if (headerFormat != null) return getHeaders(headerFormat);
        return this.format == null ? new ArrayList() : 
               this.getHeaders(this.format);
    }
    
    List getHeaders(List objs){
        return this.getHeaders(this.format != null ? this.format :
                               this.generateListFormat(objs));
    }

    void printHeaders(){
        this.printData(this.getHeaders());
    }

    void printHeaders(List objs){
        this.printData(this.getHeaders(objs));
    }

    public void setHeaders(String[] headers){
        if(headers.length != this.attributes.length)
            throw new IllegalArgumentException("Headers and attributes args " +
                                               "must be the same length");
        this.headers = headers;
    }

    /**
     * Get the value of an attribute from a value wrapper, doing 
     * possible conversion of the data based on the attribute type.
     *
     * @param wrapper   Wrapper object to retrieve values from
     * @param attribute ValueWrapper.* attribute
     * @param attrType  one of ValuePrinter.ATTRTYPE_*
     * 
     * @return An Object with a type as defined by `attrType`
     */
    private static Object getValueAttribute(ValueWrapper wrapper,
                                            int attribute, int attrType)
    {
        switch(attrType){
        case ATTRTYPE_STRING:
            String sRes;

            if((sRes = wrapper.get(attribute)) == null)
                return "";
            return sRes;
        case ATTRTYPE_INT:
            Integer iRes;

            if((iRes = wrapper.getInt(attribute)) == null)
                return new Integer(-1);
            return iRes;
        case ATTRTYPE_LONG:
            Long lRes;
            
            if((lRes = wrapper.getLong(attribute)) == null)
                return new Long(-1);
            return lRes;
        case ATTRTYPE_LONGDATE:
            String dRes;

            if((dRes = wrapper.getLongDate(attribute)) == null)
                return "* Null Date *";
            return dRes;
        case ATTRTYPE_DOUBLE:
            Double dbRes;

            if((dbRes = wrapper.getDouble(attribute)) == null)
                return new Double(-1);
            return dbRes;
        default:
            throw new IllegalArgumentException("Unknown attribute type");
        }
    }

    List getList(List objs, boolean getHeaders){
        PrintfFormat fmt;
        Object fArgs[] = new Object[this.attributes.length];
        List res;
        int size;

        size = objs.size();
        fmt = new PrintfFormat(this.format != null ? this.format :
                               this.generateListFormat(objs));

        if(getHeaders && this.headers != null){
            if(this.format != null){
                res = this.getHeaders();
            } else {
                res = this.getHeaders(objs);
            }
        } else {
            res = new ArrayList();
        }
        
        for(int i=0; i<size; i++){
            Object valObject;
            valObject = objs.get(i);
            if (valObject == null) {
                continue;
            }

            this.wrapper.setWrapee(valObject, this.auxData);

            for(int j=0; j<fArgs.length; j++){
                fArgs[j] = ValuePrinter.getValueAttribute(this.wrapper,
                                                          this.attributes[j],
                                                          this.attrTypes[j]);
            }
            res.add(fmt.sprintf(fArgs));
        }            
        return res;
    }

    List getList(List objs){
        return this.getList(objs, true);
    }

    public void printList(List objs){
        this.printData(this.getList(objs));
    }

    String getItem(ValueWrapper val){
        Object fArgs[] = new Object[this.attributes.length];
        PrintfFormat fmt;
        
        fmt = new PrintfFormat(this.format != null ? this.format : 
                               this.generateSingleLineFormat());
        for(int i=0; i<this.attributes.length; i++){
            fArgs[i] = ValuePrinter.getValueAttribute(val, this.attributes[i],
                                                      this.attrTypes[i]);
        }

        return fmt.sprintf(fArgs);
    }

    void printItem(ValueWrapper val){
        if(this.out != null)
            this.out.println(this.getItem(val));
    }
    
    private String generateListFormat(List items){
        StringBuffer res = new StringBuffer();
        int[] columnWidths;
        Object[] fArgs;

        if(headers == null){
            columnWidths = new int[this.attributes.length];
            for(int i=0; i<columnWidths.length; i++){
                columnWidths[i] = 0;
            }
        } else {
            columnWidths = getStringLengthMulti(this.headers);
        }
        
        for(Iterator i=items.iterator(); i.hasNext(); ){
            Object valObject = i.next();
            ValueWrapper valWrap;
            String sVal;

            this.wrapper.setWrapee(valObject, this.auxData);
            for(int j=0; j<columnWidths.length; j++){
                sVal = ValuePrinter.
                    getValueAttribute(this.wrapper,
                                      this.attributes[j],
                                      this.attrTypes[j]).toString();
                if(sVal.length() > columnWidths[j]){
                    columnWidths[j] = sVal.length();
                }
            }
        }

        fArgs = new Object[columnWidths.length - 1];
        for(int i=0; i<columnWidths.length; i++){
            if(i == columnWidths.length - 1){
                res.append("%%s");
                continue;
            }

            res.append("%%-%ds");
            fArgs[i] = new Integer(columnWidths[i] + 3);
        }
            
        return (new PrintfFormat(res.toString())).sprintf(fArgs);
    }

    private String generateSingleLineFormat(){
        StringBuffer res = new StringBuffer();

        if(this.headers != null){
            PrintfFormat fmt;
            Object fArgs[];
            int maxHeaderLen;

            maxHeaderLen = getLongestStringLength(this.headers);

            fArgs = new Object[this.headers.length];
            for(int i=0; i<this.attributes.length; i++){
                res.append("%-" + maxHeaderLen + "s %%s\n");
                fArgs[i] = this.headers[i] + ":";
            }

            fmt = new PrintfFormat(res.toString());
            return fmt.sprintf(fArgs);
        } else {
            for(int i=0; i<this.attributes.length; i++){
                res.append("%s\n");
            }
            return res.toString();
        }
    }

    private static int getLongestStringLength(String[] items){
        int res = -1;
    
        for(int i=0; i<items.length; i++){
            int len;
    
            len = items[i].toString().length();
            if(len > res){
                res = len;
            }
        }
        return res;
    }

    private static int[] getStringLengthMulti(String[] items){
        int[] res;
    
        res = new int[items.length];
        for(int i=0; i<items.length; i++){
            res[i] = items[i].toString().length();
        }
        return res;
    }
}
